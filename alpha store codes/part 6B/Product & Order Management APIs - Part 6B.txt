// models/Product.js
const mongoose = require('mongoose');

const productSchema = new mongoose.Schema({
  name: {
    fa: { type: String, required: true, index: true },
    en: { type: String, required: true }
  },
  slug: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  description: {
    fa: { type: String, required: true },
    en: { type: String }
  },
  shortDescription: {
    fa: { type: String, maxlength: 200 },
    en: { type: String, maxlength: 200 }
  },
  price: {
    current: { type: Number, required: true, min: 0 },
    original: { type: Number, min: 0 },
    discount: { type: Number, min: 0, max: 100, default: 0 }
  },
  category: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Category',
    required: true
  },
  subcategory: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Category'
  },
  images: [{
    url: String,
    alt: {
      fa: String,
      en: String
    },
    isPrimary: { type: Boolean, default: false }
  }],
  inventory: {
    quantity: { type: Number, required: true, min: 0 },
    sku: { type: String, unique: true, sparse: true },
    lowStockThreshold: { type: Number, default: 5 },
    trackInventory: { type: Boolean, default: true }
  },
  attributes: [{
    name: {
      fa: String,
      en: String
    },
    value: {
      fa: String,
      en: String
    },
    type: {
      type: String,
      enum: ['text', 'number', 'boolean', 'color', 'size']
    }
  }],
  specifications: [{
    key: {
      fa: String,
      en: String
    },
    value: {
      fa: String,
      en: String
    }
  }],
  seo: {
    title: {
      fa: String,
      en: String
    },
    description: {
      fa: String,
      en: String
    },
    keywords: [String]
  },
  status: {
    type: String,
    enum: ['draft', 'active', 'inactive', 'archived'],
    default: 'draft'
  },
  featured: { type: Boolean, default: false },
  rating: {
    average: { type: Number, default: 0, min: 0, max: 5 },
    count: { type: Number, default: 0 },
    breakdown: {
      1: { type: Number, default: 0 },
      2: { type: Number, default: 0 },
      3: { type: Number, default: 0 },
      4: { type: Number, default: 0 },
      5: { type: Number, default: 0 }
    }
  },
  tags: [String],
  weight: { type: Number, min: 0 }, // in grams
  dimensions: {
    length: Number,
    width: Number,
    height: Number
  },
  shipping: {
    freeShipping: { type: Boolean, default: false },
    weight: Number,
    cost: Number
  },
  vendor: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  updatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Text indexes for Persian search
productSchema.index({
  'name.fa': 'text',
  'description.fa': 'text',
  'tags': 'text'
}, {
  weights: {
    'name.fa': 10,
    'description.fa': 5,
    'tags': 3
  },
  name: 'product_search_index'
});

// Other indexes
productSchema.index({ slug: 1 });
productSchema.index({ category: 1, status: 1 });
productSchema.index({ 'price.current': 1 });
productSchema.index({ createdAt: -1 });
productSchema.index({ featured: 1, status: 1 });
productSchema.index({ 'inventory.quantity': 1 });

// Virtual for discounted price
productSchema.virtual('discountedPrice').get(function() {
  if (this.price.discount > 0) {
    return this.price.current * (1 - this.price.discount / 100);
  }
  return this.price.current;
});

// Virtual for stock status
productSchema.virtual('stockStatus').get(function() {
  if (!this.inventory.trackInventory) return 'in-stock';
  if (this.inventory.quantity === 0) return 'out-of-stock';
  if (this.inventory.quantity <= this.inventory.lowStockThreshold) return 'low-stock';
  return 'in-stock';
});

// Pre-save middleware
productSchema.pre('save', function(next) {
  if (this.isModified('name.fa') && !this.slug) {
    this.slug = this.name.fa
      .toLowerCase()
      .replace(/[^a-z0-9\u0600-\u06FF]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }
  next();
});

module.exports = mongoose.model('Product', productSchema);

// models/Category.js
const mongoose = require('mongoose');

const categorySchema = new mongoose.Schema({
  name: {
    fa: { type: String, required: true },
    en: { type: String, required: true }
  },
  slug: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  description: {
    fa: String,
    en: String
  },
  parent: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Category',
    default: null
  },
  image: {
    url: String,
    alt: {
      fa: String,
      en: String
    }
  },
  icon: String,
  level: { type: Number, default: 0 },
  path: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Category' }],
  order: { type: Number, default: 0 },
  status: {
    type: String,
    enum: ['active', 'inactive'],
    default: 'active'
  },
  seo: {
    title: {
      fa: String,
      en: String
    },
    description: {
      fa: String,
      en: String
    },
    keywords: [String]
  },
  productCount: { type: Number, default: 0 }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

categorySchema.index({ slug: 1 });
categorySchema.index({ parent: 1, status: 1 });
categorySchema.index({ level: 1, order: 1 });

// Virtual for children
categorySchema.virtual('children', {
  ref: 'Category',
  localField: '_id',
  foreignField: 'parent'
});

// Pre-save middleware to set level and path
categorySchema.pre('save', async function(next) {
  if (this.parent) {
    const parent = await this.constructor.findById(this.parent);
    if (parent) {
      this.level = parent.level + 1;
      this.path = [...parent.path, parent._id];
    }
  } else {
    this.level = 0;
    this.path = [];
  }
  next();
});

module.exports = mongoose.model('Category', categorySchema);

// models/Cart.js
const mongoose = require('mongoose');

const cartItemSchema = new mongoose.Schema({
  product: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product',
    required: true
  },
  quantity: {
    type: Number,
    required: true,
    min: 1,
    default: 1
  },
  price: {
    type: Number,
    required: true
  },
  attributes: [{
    name: String,
    value: String
  }]
}, {
  timestamps: true
});

const cartSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  sessionId: {
    type: String
  },
  items: [cartItemSchema],
  totals: {
    subtotal: { type: Number, default: 0 },
    shipping: { type: Number, default: 0 },
    tax: { type: Number, default: 0 },
    discount: { type: Number, default: 0 },
    total: { type: Number, default: 0 }
  },
  discountCode: {
    code: String,
    amount: Number,
    type: { type: String, enum: ['percentage', 'fixed'] }
  },
  expiresAt: {
    type: Date,
    default: () => new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days
  }
}, {
  timestamps: true
});

cartSchema.index({ user: 1 });
cartSchema.index({ sessionId: 1 });
cartSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

// Calculate totals before saving
cartSchema.pre('save', function(next) {
  this.totals.subtotal = this.items.reduce((sum, item) => {
    return sum + (item.price * item.quantity);
  }, 0);
  
  // Calculate tax (9% Iranian VAT)
  this.totals.tax = this.totals.subtotal * 0.09;
  
  // Apply discount
  if (this.discountCode) {
    if (this.discountCode.type === 'percentage') {
      this.totals.discount = this.totals.subtotal * (this.discountCode.amount / 100);
    } else {
      this.totals.discount = this.discountCode.amount;
    }
  }
  
  this.totals.total = this.totals.subtotal + this.totals.shipping + this.totals.tax - this.totals.discount;
  next();
});

module.exports = mongoose.model('Cart', cartSchema);

// models/Order.js
const mongoose = require('mongoose');

const orderItemSchema = new mongoose.Schema({
  product: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product',
    required: true
  },
  name: {
    fa: String,
    en: String
  },
  sku: String,
  quantity: {
    type: Number,
    required: true,
    min: 1
  },
  price: {
    type: Number,
    required: true
  },
  total: {
    type: Number,
    required: true
  },
  attributes: [{
    name: String,
    value: String
  }]
});

const orderSchema = new mongoose.Schema({
  orderNumber: {
    type: String,
    unique: true,
    required: true
  },
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  items: [orderItemSchema],
  status: {
    type: String,
    enum: ['pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled', 'refunded'],
    default: 'pending'
  },
  paymentStatus: {
    type: String,
    enum: ['pending', 'paid', 'failed', 'refunded', 'partially_refunded'],
    default: 'pending'
  },
  shippingAddress: {
    firstName: String,
    lastName: String,
    company: String,
    address1: String,
    address2: String,
    city: String,
    state: String,
    postalCode: String,
    country: { type: String, default: 'IR' },
    phone: String
  },
  billingAddress: {
    firstName: String,
    lastName: String,
    company: String,
    address1: String,
    address2: String,
    city: String,
    state: String,
    postalCode: String,
    country: { type: String, default: 'IR' },
    phone: String
  },
  totals: {
    subtotal: { type: Number, required: true },
    shipping: { type: Number, default: 0 },
    tax: { type: Number, default: 0 },
    discount: { type: Number, default: 0 },
    total: { type: Number, required: true }
  },
  discountCode: {
    code: String,
    amount: Number,
    type: String
  },
  shipping: {
    method: String,
    cost: Number,
    trackingNumber: String,
    carrier: String,
    estimatedDelivery: Date
  },
  payment: {
    method: String,
    transactionId: String,
    gateway: String,
    paidAt: Date,
    amount: Number
  },
  timeline: [{
    status: String,
    date: { type: Date, default: Date.now },
    note: String,
    updatedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    }
  }],
  notes: [{
    text: String,
    isCustomerVisible: { type: Boolean, default: false },
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    createdAt: { type: Date, default: Date.now }
  }],
  cancellation: {
    reason: String,
    requestedAt: Date,
    processedAt: Date,
    refundAmount: Number
  }
}, {
  timestamps: true
});

orderSchema.index({ orderNumber: 1 });
orderSchema.index({ user: 1, createdAt: -1 });
orderSchema.index({ status: 1 });
orderSchema.index({ paymentStatus: 1 });
orderSchema.index({ createdAt: -1 });

// Generate order number
orderSchema.pre('save', function(next) {
  if (!this.orderNumber) {
    const timestamp = Date.now().toString().slice(-8);
    const random = Math.random().toString(36).substring(2, 6).toUpperCase();
    this.orderNumber = `AS-${timestamp}-${random}`;
  }
  next();
});

// Add to timeline on status change
orderSchema.pre('save', function(next) {
  if (this.isModified('status') && !this.isNew) {
    this.timeline.push({
      status: this.status,
      date: new Date()
    });
  }
  next();
});

module.exports = mongoose.model('Order', orderSchema);

// controllers/productController.js
const Product = require('../models/Product');
const Category = require('../models/Category');
const searchService = require('../services/searchService');
const { paginate } = require('../utils/pagination');
const { validatePersianText } = require('../utils/persian');

class ProductController {
  // Get products with filtering and pagination
  async getProducts(req, res) {
    try {
      const {
        page = 1,
        limit = 12,
        category,
        subcategory,
        minPrice,
        maxPrice,
        sort = 'createdAt',
        order = 'desc',
        featured,
        status = 'active',
        search
      } = req.query;

      let query = { status };
      
      // Category filtering
      if (category) {
        query.category = category;
      }
      
      if (subcategory) {
        query.subcategory = subcategory;
      }

      // Price filtering
      if (minPrice || maxPrice) {
        query['price.current'] = {};
        if (minPrice) query['price.current'].$gte = Number(minPrice);
        if (maxPrice) query['price.current'].$lte = Number(maxPrice);
      }

      // Featured filtering
      if (featured !== undefined) {
        query.featured = featured === 'true';
      }

      // Search
      if (search) {
        const searchResults = await searchService.searchProducts(search);
        query._id = { $in: searchResults.map(r => r._id) };
      }

      // Sorting
      const sortOptions = {};
      sortOptions[sort] = order === 'desc' ? -1 : 1;

      const options = {
        page: parseInt(page),
        limit: parseInt(limit),
        sort: sortOptions,
        populate: [
          { path: 'category', select: 'name slug' },
          { path: 'subcategory', select: 'name slug' }
        ]
      };

      const products = await paginate(Product, query, options);

      res.json({
        success: true,
        data: products,
        message: 'محصولات با موفقیت دریافت شدند'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در دریافت محصولات',
        error: error.message
      });
    }
  }

  // Get single product by slug
  async getProduct(req, res) {
    try {
      const { slug } = req.params;
      
      const product = await Product.findOne({ slug, status: 'active' })
        .populate('category', 'name slug')
        .populate('subcategory', 'name slug');

      if (!product) {
        return res.status(404).json({
          success: false,
          message: 'محصول یافت نشد'
        });
      }

      // Get related products
      const relatedProducts = await Product.find({
        category: product.category._id,
        _id: { $ne: product._id },
        status: 'active'
      })
      .limit(8)
      .select('name slug price images rating');

      res.json({
        success: true,
        data: {
          product,
          relatedProducts
        },
        message: 'محصول با موفقیت دریافت شد'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در دریافت محصول',
        error: error.message
      });
    }
  }

  // Search products
  async searchProducts(req, res) {
    try {
      const { q, page = 1, limit = 12 } = req.query;
      
      if (!q) {
        return res.status(400).json({
          success: false,
          message: 'عبارت جستجو الزامی است'
        });
      }

      const results = await searchService.searchProducts(q, {
        page: parseInt(page),
        limit: parseInt(limit)
      });

      res.json({
        success: true,
        data: results,
        message: 'نتایج جستجو با موفقیت دریافت شدند'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در جستجو',
        error: error.message
      });
    }
  }

  // Create product (admin only)
  async createProduct(req, res) {
    try {
      const productData = {
        ...req.body,
        createdBy: req.user.id
      };

      const product = new Product(productData);
      await product.save();

      // Update category product count
      if (product.category) {
        await Category.findByIdAndUpdate(
          product.category,
          { $inc: { productCount: 1 } }
        );
      }

      res.status(201).json({
        success: true,
        data: product,
        message: 'محصول با موفقیت ایجاد شد'
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        message: 'خطا در ایجاد محصول',
        error: error.message
      });
    }
  }

  // Update product (admin only)
  async updateProduct(req, res) {
    try {
      const { id } = req.params;
      
      const product = await Product.findByIdAndUpdate(
        id,
        {
          ...req.body,
          updatedBy: req.user.id
        },
        { new: true, runValidators: true }
      );

      if (!product) {
        return res.status(404).json({
          success: false,
          message: 'محصول یافت نشد'
        });
      }

      res.json({
        success: true,
        data: product,
        message: 'محصول با موفقیت بروزرسانی شد'
      });
    } catch (error) {
      res.status(400).json({
        success: false,
        message: 'خطا در بروزرسانی محصول',
        error: error.message
      });
    }
  }

  // Delete product (admin only)
  async deleteProduct(req, res) {
    try {
      const { id } = req.params;
      
      const product = await Product.findByIdAndDelete(id);

      if (!product) {
        return res.status(404).json({
          success: false,
          message: 'محصول یافت نشد'
        });
      }

      // Update category product count
      if (product.category) {
        await Category.findByIdAndUpdate(
          product.category,
          { $inc: { productCount: -1 } }
        );
      }

      res.json({
        success: true,
        message: 'محصول با موفقیت حذف شد'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در حذف محصول',
        error: error.message
      });
    }
  }
}

module.exports = new ProductController();

// controllers/categoryController.js
const Category = require('../models/Category');

class CategoryController {
  // Get all categories with hierarchy
  async getCategories(req, res) {
    try {
      const { level, parent, status = 'active' } = req.query;
      
      let query = { status };
      
      if (level !== undefined) {
        query.level = parseInt(level);
      }
      
      if (parent !== undefined) {
        query.parent = parent === 'null' ? null : parent;
      }

      const categories = await Category.find(query)
        .populate('parent', 'name slug')
        .populate('children')
        .sort({ level: 1, order: 1 });

      res.json({
        success: true,
        data: categories,
        message: 'دسته‌بندی‌ها با موفقیت دریافت شدند'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در دریافت دسته‌بندی‌ها',
        error: error.message
      });
    }
  }

  // Get category by slug with products
  async getCategoryProducts(req, res) {
    try {
      const { slug } = req.params;
      const {
        page = 1,
        limit = 12,
        sort = 'createdAt',
        order = 'desc',
        minPrice,
        maxPrice
      } = req.query;

      const category = await Category.findOne({ slug, status: 'active' });
      
      if (!category) {
        return res.status(404).json({
          success: false,
          message: 'دسته‌بندی یافت نشد'
        });
      }

      // Build product query
      let productQuery = { category: category._id, status: 'active' };
      
      if (minPrice || maxPrice) {
        productQuery['price.current'] = {};
        if (minPrice) productQuery['price.current'].$gte = Number(minPrice);
        if (maxPrice) productQuery['price.current'].$lte = Number(maxPrice);
      }

      const sortOptions = {};
      sortOptions[sort] = order === 'desc' ? -1 : 1;

      const options = {
        page: parseInt(page),
        limit: parseInt(limit),
        sort: sortOptions,
        populate: [
          { path: 'category', select: 'name slug' }
        ]
      };

      const Product = require('../models/Product');
      const products = await paginate(Product, productQuery, options);

      res.json({
        success: true,
        data: {
          category,
          products
        },
        message: 'محصولات دسته‌بندی با موفقیت دریافت شدند'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در دریافت محصولات دسته‌بندی',
        error: error.message
      });
    }
  }
}

module.exports = new CategoryController();

// controllers/cartController.js
const Cart = require('../models/Cart');
const Product = require('../models/Product');

class CartController {
  // Get user cart
  async getCart(req, res) {
    try {
      const query = req.user ? { user: req.user.id } : { sessionId: req.sessionID };
      
      let cart = await Cart.findOne(query)
        .populate({
          path: 'items.product',
          select: 'name slug price images inventory status'
        });

      if (!cart) {
        cart = new Cart(query);
        await cart.save();
      }

      res.json({
        success: true,
        data: cart,
        message: 'سبد خرید با موفقیت دریافت شد'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در دریافت سبد خرید',
        error: error.message
      });
    }
  }

  // Add item to cart
  async addToCart(req, res) {
    try {
      const { productId, quantity = 1, attributes = [] } = req.body;
      
      // Validate product
      const product = await Product.findById(productId);
      if (!product || product.status !== 'active') {
        return res.status(404).json({
          success: false,
          message: 'محصول یافت نشد'
        });
      }

      // Check inventory
      if (product.inventory.trackInventory && product.inventory.quantity < quantity) {
        return res.status(400).json({
          success: false,
          message: 'موجودی کافی نیست'
        });
      }

      const query = req.user ? { user: req.user.id } : { sessionId: req.sessionID };
      
      let cart = await Cart.findOne(query);
      if (!cart) {
        cart = new Cart(query);
      }

      // Check if item already exists
      const existingItemIndex = cart.items.findIndex(item => 
        item.product.toString() === productId && 
        JSON.stringify(item.attributes) === JSON.stringify(attributes)
      );

      if (existingItemIndex > -1) {
        // Update quantity
        cart.items[existingItemIndex].quantity += quantity;
        
        // Check inventory again
        if (product.inventory.trackInventory && 
            cart.items[existingItemIndex].quantity > product.inventory.quantity) {
          return res.status(400).json({
            success: false,
            message: 'موجودی کافی نیست'
          });
        }
      } else {
        // Add new item
        cart.items.push({
          product: productId,
          quantity,
          price: product.discountedPrice || product.price.current,
          attributes
        });
      }

      await cart.save();

      // Populate and return
      await cart.populate({
        path: 'items.product',
        select: 'name slug price images inventory status'
      });

      res.json({
        success: true,
        data: cart,
        message: 'محصول به سبد خرید اضافه شد'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در افزودن محصول به سبد خرید',
        error: error.message
      });
    }
  }

  // Update cart item quantity
  async updateCartItem(req, res) {
    try {
      const { itemId, quantity } = req.body;
      
      if (quantity < 1) {
        return res.status(400).json({
          success: false,
          message: 'تعداد باید حداقل 1 باشد'
        });
      }

      const query = req.user ? { user: req.user.id } : { sessionId: req.sessionID };
      
      const cart = await Cart.findOne(query);
      if (!cart) {
        return res.status(404).json({
          success: false,
          message: 'سبد خرید یافت نشد'
        });
      }

      const item = cart.items.id(itemId);
      if (!item) {
        return res.status(404).json({
          success: false,
          message: 'آیتم در سبد خرید یافت نشد'
        });
      }

      // Check inventory
      const product = await Product.findById(item.product);
      if (product.inventory.trackInventory && product.inventory.quantity < quantity) {
        return res.status(400).json({
          success: false,
          message: 'موجودی کافی نیست'
        });
      }

      item.quantity = quantity;
      await cart.save();

      await cart.populate({
        path: 'items.product',
        select: 'name slug price images inventory status'
      });

      res.json({
        success: true,
        data: cart,
        message: 'سبد خرید بروزرسانی شد'
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'خطا در بروز