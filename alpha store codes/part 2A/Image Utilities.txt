// src/utils/images.ts

import { ProductImage } from '../types/product';

/**
 * Generate optimized image URL with different sizes
 */
export function generateImageUrl(
  baseUrl: string,
  width: number,
  height?: number,
  quality: number = 80
): string {
  if (baseUrl.includes('unsplash.com')) {
    const params = new URLSearchParams({
      w: width.toString(),
      h: (height || width).toString(),
      fit: 'crop',
      q: quality.toString()
    });
    return `${baseUrl}&${params.toString()}`;
  }

  // For other image services, return the original URL
  return baseUrl;
}

/**
 * Generate multiple image variants for responsive design
 */
export interface ImageVariant {
  url: string;
  width: number;
  height: number;
  density: number;
}

export function generateImageVariants(
  baseUrl: string,
  baseWidth: number,
  baseHeight?: number
): ImageVariant[] {
  const height = baseHeight || baseWidth;
  
  return [
    {
      url: generateImageUrl(baseUrl, baseWidth, height),
      width: baseWidth,
      height: height,
      density: 1
    },
    {
      url: generateImageUrl(baseUrl, baseWidth * 1.5, height * 1.5),
      width: baseWidth * 1.5,
      height: height * 1.5,
      density: 1.5
    },
    {
      url: generateImageUrl(baseUrl, baseWidth * 2, height * 2),
      width: baseWidth * 2,
      height: height * 2,
      density: 2
    }
  ];
}

/**
 * Generate srcSet string for responsive images
 */
export function generateSrcSet(variants: ImageVariant[]): string {
  return variants
    .map(variant => `${variant.url} ${variant.density}x`)
    .join(', ');
}

/**
 * Get optimized image props for Next.js Image component
 */
export interface OptimizedImageProps {
  src: string;
  srcSet?: string;
  sizes?: string;
  width: number;
  height: number;
  alt: string;
}

export function getOptimizedImageProps(
  image: ProductImage,
  targetWidth: number,
  targetHeight?: number,
  sizes?: string
): OptimizedImageProps {
  const height = targetHeight || targetWidth;
  const variants = generateImageVariants(image.url, targetWidth, height);
  
  return {
    src: variants[0].url,
    srcSet: generateSrcSet(variants),
    sizes: sizes || `${targetWidth}px`,
    width: targetWidth,
    height: height,
    alt: image.alt
  };
}

/**
 * Create placeholder image URL (base64 blur)
 */
export function createImagePlaceholder(
  width: number = 400,
  height: number = 400,
  color: string = '#f3f4f6'
): string {
  const svg = `
    <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="${color}"/>
      <text x="50%" y="50%" text-anchor="middle" dy=".3em" fill="#9ca3af" font-family="Arial, sans-serif" font-size="16">
        Loading...
      </text>
    </svg>
  `;
  
  return `data:image/svg+xml;base64,${btoa(svg)}`;
}

/**
 * Create error placeholder image
 */
export function createErrorPlaceholder(
  width: number = 400,
  height: number = 400
): string {
  const svg = `
    <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="#fef2f2"/>
      <text x="50%" y="50%" text-anchor="middle" dy=".3em" fill="#dc2626" font-family="Arial, sans-serif" font-size="14">
        Image Error
      </text>
    </svg>
  `;
  
  return `data:image/svg+xml;base64,${btoa(svg)}`;
}

/**
 * Validate image URL
 */
export function isValidImageUrl(url: string): boolean {
  try {
    const parsedUrl = new URL(url);
    return ['http:', 'https:', 'data:'].includes(parsedUrl.protocol);
  } catch {
    return false;
  }
}

/**
 * Extract image dimensions from URL (for Unsplash)
 */
export function extractImageDimensions(url: string): { width?: number; height?: number } {
  try {
    const urlObj = new URL(url);
    const width = urlObj.searchParams.get('w');
    const height = urlObj.searchParams.get('h');
    
    return {
      width: width ? parseInt(width) : undefined,
      height: height ? parseInt(height) : undefined
    };
  } catch {
    return {};
  }
}

/**
 * Lazy loading intersection observer options
 */
export const lazyLoadingConfig = {
  rootMargin: '50px 0px',
  threshold: 0.1
};

/**
 * Preload critical images
 */
export function preloadImage(src: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve();
    img.onerror = reject;
    img.src = src;
  });
}

/**
 * Image compression quality settings
 */
export const imageQualitySettings = {
  thumbnail: 60,
  card: 80,
  detail: 90,
  zoom: 95
};

/**
 * Common image sizes for e-commerce
 */
export const imageSizes = {
  thumbnail: { width: 80, height: 80 },
  cardSmall: { width: 200, height: 200 },
  cardMedium: { width: 300, height: 300 },
  cardLarge: { width: 400, height: 400 },
  detail: { width: 600, height: 600 },
  zoom: { width: 1200, height: 1200 },
  category: { width: 400, height: 300 },
  banner: { width: 1200, height: 400 }
};

/**
 * Generate image alt text from product info
 */
export function generateImageAlt(
  productName: string,
  imageIndex: number = 0,
  locale: 'fa' | 'en' = 'fa'
): string {
  if (imageIndex === 0) {
    return productName;
  }
  
  const suffix = locale === 'fa' ? `- تصویر ${imageIndex + 1}` : `- Image ${imageIndex + 1}`;
  return `${productName} ${suffix}`;
}

/**
 * Handle image loading errors
 */
export function handleImageError(
  event: React.SyntheticEvent<HTMLImageElement>,
  fallbackSrc?: string
): void {
  const img = event.currentTarget;
  
  if (fallbackSrc && img.src !== fallbackSrc) {
    img.src = fallbackSrc;
  } else {
    img.src = createErrorPlaceholder(img.width, img.height);
  }
}